
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/khulnasoft/meshplay-operator/api/v1alpha1/broker_types.go (100.0%)</option>
				
				<option value="file1">github.com/khulnasoft/meshplay-operator/api/v1alpha1/meshsync_types.go (100.0%)</option>
				
				<option value="file2">github.com/khulnasoft/meshplay-operator/api/v1alpha1/zz_generated.deepcopy.go (50.4%)</option>
				
				<option value="file3">github.com/khulnasoft/meshplay-operator/controllers/broker_controller.go (49.1%)</option>
				
				<option value="file4">github.com/khulnasoft/meshplay-operator/controllers/error.go (100.0%)</option>
				
				<option value="file5">github.com/khulnasoft/meshplay-operator/controllers/meshsync_controller.go (53.4%)</option>
				
				<option value="file6">github.com/khulnasoft/meshplay-operator/pkg/broker/broker.go (54.4%)</option>
				
				<option value="file7">github.com/khulnasoft/meshplay-operator/pkg/broker/error.go (100.0%)</option>
				
				<option value="file8">github.com/khulnasoft/meshplay-operator/pkg/meshsync/meshsync.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// BrokerSpec defines the desired state of Broker
type BrokerSpec struct {
        Size int32 `json:"size,omitempty" yaml:"size,omitempty"`
}

type Endpoint struct {
        Internal string `json:"internal,omitempty" yaml:"internal,omitempty"`
        External string `json:"external,omitempty" yaml:"external,omitempty"`
}

// BrokerStatus defines the observed state of Broker
type BrokerStatus struct {
        Endpoint   Endpoint    `json:"endpoint,omitempty" yaml:"endpoint,omitempty"`
        Conditions []Condition `json:"conditions,omitempty" yaml:"conditions,omitempty"`
}

// Broker is the Schema for the brokers API
// +kubebuilder:subresource:status
// +kubebuilder:object:root=true
type Broker struct {
        metav1.TypeMeta   `json:",inline" yaml:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty" yaml:"metadata,omitempty"`

        Spec   BrokerSpec   `json:"spec,omitempty" yaml:"spec,omitempty"`
        Status BrokerStatus `json:"status,omitempty" yaml:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BrokerList contains a list of Broker
type BrokerList struct {
        metav1.TypeMeta `json:",inline" yaml:",inline"`
        metav1.ListMeta `json:"metadata,omitempty" yaml:"metadata,omitempty"`
        Items           []Broker `json:"items" yaml:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;Broker{}, &amp;BrokerList{})
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2020 Khulnasoft, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type CustomMeshsyncBroker struct {
        URL string `json:"url,omitempty" yaml:"url,omitempty"`
}

type NativeMeshsyncBroker struct {
        Name      string `json:"name,omitempty" yaml:"name,omitempty"`
        Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`
}

type MeshsyncBroker struct {
        Custom CustomMeshsyncBroker `json:"custom,omitempty" yaml:"custom,omitempty"`
        Native NativeMeshsyncBroker `json:"native,omitempty" yaml:"native,omitempty"`
}

// MeshSyncSpec defines the desired state of MeshSync
type MeshSyncSpec struct {
        Size      int32            `json:"size,omitempty" yaml:"size,omitempty"`
        Broker    MeshsyncBroker   `json:"broker,omitempty" yaml:"broker,omitempty"`
        WatchList corev1.ConfigMap `json:"watch-list,omitempty" yaml:"watch-list,omitempty"`
}

// MeshSyncStatus defines the observed state of MeshSync
type MeshSyncStatus struct {
        PublishingTo string      `json:"publishing-to,omitempty" yaml:"publishing-to,omitempty"`
        Conditions   []Condition `json:"conditions,omitempty" yaml:"conditions,omitempty"`
}

// MeshSync is the Schema for the meshsyncs API
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
type MeshSync struct {
        metav1.TypeMeta   `json:",inline" yaml:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty" yaml:"metadata,omitempty"`

        Spec   MeshSyncSpec   `json:"spec,omitempty" yaml:"spec,omitempty"`
        Status MeshSyncStatus `json:"status,omitempty" yaml:"status,omitempty"`
}

// MeshSyncList contains a list of MeshSync
// +kubebuilder:object:root=true
type MeshSyncList struct {
        metav1.TypeMeta `json:",inline" yaml:",inline"`
        metav1.ListMeta `json:"metadata,omitempty" yaml:"metadata,omitempty"`
        Items           []MeshSync `json:"items" yaml:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;MeshSync{}, &amp;MeshSyncList{})
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*


Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
        runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Broker) DeepCopyInto(out *Broker) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        out.Spec = in.Spec
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Broker.
func (in *Broker) DeepCopy() *Broker <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(Broker)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Broker) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BrokerList) DeepCopyInto(out *BrokerList) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]Broker, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BrokerList.
func (in *BrokerList) DeepCopy() *BrokerList <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(BrokerList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *BrokerList) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BrokerSpec) DeepCopyInto(out *BrokerSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BrokerSpec.
func (in *BrokerSpec) DeepCopy() *BrokerSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BrokerSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BrokerStatus) DeepCopyInto(out *BrokerStatus) <span class="cov8" title="1">{
        *out = *in
        out.Endpoint = in.Endpoint
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make([]Condition, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BrokerStatus.
func (in *BrokerStatus) DeepCopy() *BrokerStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BrokerStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Condition) DeepCopyInto(out *Condition) <span class="cov8" title="1">{
        *out = *in
        in.LastProbeTime.DeepCopyInto(&amp;out.LastProbeTime)
        in.LastTransitionTime.DeepCopyInto(&amp;out.LastTransitionTime)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Condition.
func (in *Condition) DeepCopy() *Condition <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Condition)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CustomMeshsyncBroker) DeepCopyInto(out *CustomMeshsyncBroker) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CustomMeshsyncBroker.
func (in *CustomMeshsyncBroker) DeepCopy() *CustomMeshsyncBroker <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(CustomMeshsyncBroker)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Endpoint) DeepCopyInto(out *Endpoint) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Endpoint.
func (in *Endpoint) DeepCopy() *Endpoint <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Endpoint)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MeshSync) DeepCopyInto(out *MeshSync) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshSync.
func (in *MeshSync) DeepCopy() *MeshSync <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(MeshSync)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *MeshSync) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MeshSyncList) DeepCopyInto(out *MeshSyncList) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]MeshSync, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshSyncList.
func (in *MeshSyncList) DeepCopy() *MeshSyncList <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(MeshSyncList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *MeshSyncList) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MeshSyncSpec) DeepCopyInto(out *MeshSyncSpec) <span class="cov8" title="1">{
        *out = *in
        out.Broker = in.Broker
        in.WatchList.DeepCopyInto(&amp;out.WatchList)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshSyncSpec.
func (in *MeshSyncSpec) DeepCopy() *MeshSyncSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(MeshSyncSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MeshSyncStatus) DeepCopyInto(out *MeshSyncStatus) <span class="cov8" title="1">{
        *out = *in
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make([]Condition, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshSyncStatus.
func (in *MeshSyncStatus) DeepCopy() *MeshSyncStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(MeshSyncStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MeshsyncBroker) DeepCopyInto(out *MeshsyncBroker) <span class="cov0" title="0">{
        *out = *in
        out.Custom = in.Custom
        out.Native = in.Native
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MeshsyncBroker.
func (in *MeshsyncBroker) DeepCopy() *MeshsyncBroker <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(MeshsyncBroker)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NativeMeshsyncBroker) DeepCopyInto(out *NativeMeshsyncBroker) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NativeMeshsyncBroker.
func (in *NativeMeshsyncBroker) DeepCopy() *NativeMeshsyncBroker <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NativeMeshsyncBroker)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2023 Khulnasoft, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "github.com/go-logr/logr"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"

        meshplayv1alpha1 "github.com/khulnasoft/meshplay-operator/api/v1alpha1"
        brokerpackage "github.com/khulnasoft/meshplay-operator/pkg/broker"
        "github.com/khulnasoft/meshplay-operator/pkg/utils"
        kubeerror "k8s.io/apimachinery/pkg/api/errors"
        types "k8s.io/apimachinery/pkg/types"
)

// BrokerReconciler reconciles a Broker object
type BrokerReconciler struct {
        client.Client
        KubeConfig *rest.Config
        Clientset  *kubernetes.Clientset
        Log        logr.Logger
        Scheme     *runtime.Scheme
}

// +kubebuilder:rbac:groups=meshplay.khulnasoft.com,resources=brokers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=meshplay.khulnasoft.com,resources=brokers/status,verbs=get;update;patch

func (r *BrokerReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := r.Log
        log = log.WithValues("controller", "Broker")
        log = log.WithValues("namespace", req.NamespacedName)
        log.Info("Reconciling broker")
        baseResource := &amp;meshplayv1alpha1.Broker{}

        // Check if resource exists
        err := r.Get(ctx, req.NamespacedName, baseResource)
        if err != nil </span><span class="cov8" title="1">{
                if kubeerror.IsNotFound(err) </span><span class="cov8" title="1">{
                        baseResource.Name = req.Name
                        baseResource.Namespace = req.Namespace
                        return r.reconcileBroker(ctx, false, baseResource, req)
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        // Check if Broker controller deployed
        <span class="cov8" title="1">result, err := r.reconcileBroker(ctx, true, baseResource, req)
        if err != nil </span><span class="cov8" title="1">{
                return ctrl.Result{}, ErrReconcileBroker(err)
        }</span>

        // Check if Broker controller started
        <span class="cov0" title="0">err = brokerpackage.CheckHealth(ctx, baseResource, r.Clientset)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{Requeue: true}, ErrCheckHealth(err)
        }</span>

        // Get broker endpoint
        <span class="cov0" title="0">err = brokerpackage.GetEndpoint(ctx, baseResource, r.Clientset, r.KubeConfig.Host)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, ErrGetEndpoint(err)
        }</span>

        // Patch the broker resource
        <span class="cov0" title="0">patch, err := utils.Marshal(baseResource)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, ErrUpdateResource(err)
        }</span>

        <span class="cov0" title="0">err = r.Status().Patch(ctx, baseResource, client.RawPatch(types.MergePatchType, []byte(patch)))
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, ErrUpdateResource(err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *BrokerReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;meshplayv1alpha1.Broker{}).
                Complete(r)
}</span>

func (r *BrokerReconciler) Cleanup() error <span class="cov0" title="0">{
        objects := brokerpackage.GetObjects(&amp;meshplayv1alpha1.Broker{
                ObjectMeta: v1.ObjectMeta{
                        Name:      "meshplay-broker",
                        Namespace: "meshplay",
                },
        })
        for _, object := range objects </span><span class="cov0" title="0">{
                err := r.Delete(context.TODO(), object)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrDeleteMeshsync(err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *BrokerReconciler) reconcileBroker(ctx context.Context, enable bool, baseResource *meshplayv1alpha1.Broker, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        objects := brokerpackage.GetObjects(baseResource)
        for _, object := range objects </span><span class="cov8" title="1">{
                object.SetNamespace(baseResource.Namespace)
                err := r.Get(ctx,
                        types.NamespacedName{
                                Name:      object.GetName(),
                                Namespace: object.GetNamespace(),
                        },
                        object,
                )
                if err != nil &amp;&amp; kubeerror.IsNotFound(err) &amp;&amp; enable </span><span class="cov8" title="1">{
                        _ = ctrl.SetControllerReference(baseResource, object, r.Scheme)
                        er := r.Create(ctx, object)
                        if er != nil </span><span class="cov8" title="1">{
                                return ctrl.Result{}, ErrCreateMeshsync(er)
                        }</span>
                        <span class="cov0" title="0">return ctrl.Result{Requeue: true}, nil</span>
                } else<span class="cov8" title="1"> if err != nil &amp;&amp; enable </span><span class="cov0" title="0">{
                        return ctrl.Result{}, ErrGetMeshsync(err)
                }</span> else<span class="cov8" title="1"> if err == nil &amp;&amp; !kubeerror.IsNotFound(err) &amp;&amp; !enable </span><span class="cov0" title="0">{
                        er := r.Delete(ctx, object)
                        if er != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, ErrDeleteMeshsync(er)
                        }</span>
                        <span class="cov0" title="0">return ctrl.Result{Requeue: true}, nil</span>
                }
        }

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2023 Khulnasoft, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package controllers

import (
        "errors"
)

// Error codes
// @Aisuko Is there any way to make this more flexible?
const (
        ErrGetMeshsyncCode       = "1001"
        ErrCreateMeshsyncCode    = "1002"
        ErrReconcileMeshsyncCode = "1003"
        ErrGetBrokerCode         = "1004"
        ErrCreateBrokerCode      = "1005"
        ErrReconcileBrokerCode   = "1006"
        ErrReconcileCRCode       = "1007"
        ErrDeleteMeshsyncCode    = "1008"
        ErrDeleteBrokerCode      = "1009"
        ErrCheckHealthCode       = "1010"
        ErrGetEndpointCode       = "1011"
        ErrUpdateResourceCode    = "1012"
        ErrMarshalCode           = "11049"
)

// Error definitions
func ErrGetMeshsync(err error) error <span class="cov8" title="1">{
        return errors.New(ErrGetMeshsyncCode + ":" + "Unable to get meshsync resource")
}</span>

func ErrCreateMeshsync(err error) error <span class="cov8" title="1">{
        return errors.New(ErrCreateMeshsyncCode + ":" + "Unable to create meshsync controller")
}</span>

func ErrDeleteMeshsync(err error) error <span class="cov8" title="1">{
        return errors.New(ErrDeleteMeshsyncCode + ":" + "Unable to delete meshsync controller")
}</span>

func ErrReconcileMeshsync(err error) error <span class="cov8" title="1">{
        return errors.New(ErrReconcileMeshsyncCode + ":" + "Error during meshsync resource reconciliation")
}</span>

func ErrGetBroker(err error) error <span class="cov8" title="1">{
        return errors.New(ErrGetBrokerCode + ":" + "Broker resource not found")
}</span>

func ErrCreateBroker(err error) error <span class="cov8" title="1">{
        return errors.New(ErrCreateBrokerCode + ":" + "Unable to create broker controller")
}</span>

func ErrDeleteBroker(err error) error <span class="cov8" title="1">{
        return errors.New(ErrDeleteBrokerCode + ":" + "Unable to delete broker controller")
}</span>

func ErrReconcileBroker(err error) error <span class="cov8" title="1">{
        return errors.New(ErrReconcileBrokerCode + ":" + "Error during broker resource reconciliation")
}</span>

func ErrReconcileCR(err error) error <span class="cov8" title="1">{
        return errors.New(ErrReconcileCRCode + ":" + "Error during custom resource reconciliation")
}</span>

func ErrCheckHealth(err error) error <span class="cov8" title="1">{
        return errors.New(ErrCheckHealthCode + ":" + "Error during health check")
}</span>

func ErrGetEndpoint(err error) error <span class="cov8" title="1">{
        return errors.New(ErrGetEndpointCode + ":" + "Unable to get endpoint")
}</span>

func ErrUpdateResource(err error) error <span class="cov8" title="1">{
        return errors.New(ErrUpdateResourceCode + ":" + "Unable to update resource")
}</span>

func ErrMarshal(err error) error <span class="cov8" title="1">{
        return errors.New(ErrMarshalCode + ":" + "Error during marshaling")
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2020 Khulnasoft, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "github.com/go-logr/logr"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        util "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

        meshplayv1alpha1 "github.com/khulnasoft/meshplay-operator/api/v1alpha1"
        brokerpackage "github.com/khulnasoft/meshplay-operator/pkg/broker"
        meshsyncpackage "github.com/khulnasoft/meshplay-operator/pkg/meshsync"
        "github.com/khulnasoft/meshplay-operator/pkg/utils"
        kubeerror "k8s.io/apimachinery/pkg/api/errors"
        types "k8s.io/apimachinery/pkg/types"
)

// MeshSyncReconciler reconciles a MeshSync object
type MeshSyncReconciler struct {
        client.Client
        KubeConfig *rest.Config
        Clientset  *kubernetes.Clientset
        Log        logr.Logger
        Scheme     *runtime.Scheme
}

// +kubebuilder:rbac:groups=meshplay.khulnasoft.com,resources=meshsyncs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=meshplay.khulnasoft.com,resources=meshsyncs/status,verbs=get;update;patch
func (r *MeshSyncReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := r.Log
        log = log.WithValues("controller", "MeshSync")
        log = log.WithValues("namespace", req.NamespacedName)
        log.Info("Reconciling MeshSync")
        baseResource := &amp;meshplayv1alpha1.MeshSync{}

        // Check if resource exists
        err := r.Get(ctx, req.NamespacedName, baseResource)
        if err != nil </span><span class="cov8" title="1">{
                if kubeerror.IsNotFound(err) </span><span class="cov8" title="1">{
                        baseResource.Name = req.Name
                        baseResource.Namespace = req.Namespace
                        return r.reconcileMeshsync(ctx, false, baseResource, req)
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        // Get broker configuration
        <span class="cov8" title="1">err = r.reconcileBrokerConfig(ctx, baseResource)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, ErrReconcileMeshsync(err)
        }</span>

        // Check if Meshsync controller running
        <span class="cov8" title="1">result, err := r.reconcileMeshsync(ctx, true, baseResource, req)
        if err != nil </span><span class="cov8" title="1">{
                return ctrl.Result{}, ErrReconcileMeshsync(err)
        }</span>

        // Patch the meshsync resource
        <span class="cov0" title="0">patch, err := utils.Marshal(baseResource)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, ErrUpdateResource(err)
        }</span>

        <span class="cov0" title="0">err = r.Status().Patch(ctx, baseResource, client.RawPatch(types.MergePatchType, []byte(patch)))
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, ErrUpdateResource(err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *MeshSyncReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;meshplayv1alpha1.MeshSync{}).
                Complete(r)
}</span>

func (r *MeshSyncReconciler) Cleanup() error <span class="cov0" title="0">{
        objects := meshsyncpackage.GetObjects(&amp;meshplayv1alpha1.MeshSync{
                ObjectMeta: v1.ObjectMeta{
                        Name:      "meshplay-meshsync",
                        Namespace: "meshplay",
                },
        })
        for _, object := range objects </span><span class="cov0" title="0">{
                err := r.Delete(context.TODO(), object)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrDeleteMeshsync(err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *MeshSyncReconciler) reconcileBrokerConfig(ctx context.Context, baseResource *meshplayv1alpha1.MeshSync) error <span class="cov8" title="1">{
        brokerresource := &amp;meshplayv1alpha1.Broker{}
        nullNativeResource := meshplayv1alpha1.NativeMeshsyncBroker{}
        if baseResource.Spec.Broker.Native != nullNativeResource </span><span class="cov0" title="0">{
                brokerresource.ObjectMeta.Namespace = baseResource.Spec.Broker.Native.Namespace
                brokerresource.ObjectMeta.Name = baseResource.Spec.Broker.Native.Name
                err := brokerpackage.GetEndpoint(ctx, brokerresource, r.Clientset, r.KubeConfig.Host)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrGetEndpoint(err)
                }</span>
                <span class="cov0" title="0">baseResource.Status.PublishingTo = brokerresource.Status.Endpoint.Internal</span>
        }

        // Add handler for custom broker config

        <span class="cov8" title="1">return nil</span>
}

func (r *MeshSyncReconciler) reconcileMeshsync(ctx context.Context, enable bool, baseResource *meshplayv1alpha1.MeshSync, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        object := meshsyncpackage.GetObjects(baseResource)[meshsyncpackage.ServerObject]
        err := r.Get(ctx,
                types.NamespacedName{
                        Name:      baseResource.Name,
                        Namespace: baseResource.Namespace,
                },
                object,
        )
        if err != nil &amp;&amp; kubeerror.IsNotFound(err) &amp;&amp; enable </span><span class="cov8" title="1">{
                _ = util.SetControllerReference(baseResource, object, r.Scheme)
                er := r.Create(ctx, object)
                if er != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, ErrCreateMeshsync(er)
                }</span>
                <span class="cov0" title="0">return ctrl.Result{Requeue: true}, nil</span>
        } else<span class="cov8" title="1"> if err != nil &amp;&amp; enable </span><span class="cov0" title="0">{
                return ctrl.Result{}, ErrGetMeshsync(err)
        }</span> else<span class="cov8" title="1"> if err == nil &amp;&amp; !kubeerror.IsNotFound(err) &amp;&amp; !enable </span><span class="cov0" title="0">{
                er := r.Delete(ctx, object)
                if er != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, ErrDeleteMeshsync(er)
                }</span>
                <span class="cov0" title="0">return ctrl.Result{Requeue: true}, nil</span>
        }

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package broker

import (
        "context"
        "fmt"
        "net"
        neturl "net/url"

        meshplayv1alpha1 "github.com/khulnasoft/meshplay-operator/api/v1alpha1"
        utils "github.com/khulnasoft/meshplay-operator/pkg/utils"
        v1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
)

const (
        ServerConfig  = "server-config"
        AccountConfig = "account-config"
        ServerObject  = "server-object"
        ServiceObject = "service-object"
)

type Object interface {
        runtime.Object
        metav1.Object
}

func GetObjects(m *meshplayv1alpha1.Broker) map[string]Object <span class="cov8" title="1">{
        return map[string]Object{
                ServerConfig:  getServerConfig(),
                AccountConfig: getAccountConfig(),
                ServerObject:  getServerObject(m.ObjectMeta.Namespace, m.ObjectMeta.Name, m.Spec.Size),
                ServiceObject: getServiceObject(m.ObjectMeta.Namespace, m.ObjectMeta.Name),
        }
}</span>

func getServerObject(namespace, name string, replicas int32) Object <span class="cov8" title="1">{
        var obj = &amp;v1.StatefulSet{}
        StatefulSet.DeepCopyInto(obj)
        obj.ObjectMeta.Namespace = namespace
        obj.ObjectMeta.Name = name
        obj.Spec.Replicas = &amp;replicas
        return obj
}</span>

func getServiceObject(namespace, name string) Object <span class="cov8" title="1">{
        var obj = &amp;corev1.Service{}
        Service.DeepCopyInto(obj)
        obj.ObjectMeta.Name = name
        obj.ObjectMeta.Namespace = namespace
        return obj
}</span>

func getServerConfig() Object <span class="cov8" title="1">{
        var obj = &amp;corev1.ConfigMap{}
        NatsConfigMap.DeepCopyInto(obj)
        return obj
}</span>

func getAccountConfig() Object <span class="cov8" title="1">{
        var obj = &amp;corev1.ConfigMap{}
        AccountsConfigMap.DeepCopyInto(obj)
        return obj
}</span>

func CheckHealth(ctx context.Context, m *meshplayv1alpha1.Broker, client *kubernetes.Clientset) error <span class="cov8" title="1">{
        obj, err := client.AppsV1().StatefulSets(m.ObjectMeta.Namespace).Get(ctx, m.ObjectMeta.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return ErrGettingResource(err)
        }</span>

        <span class="cov8" title="1">if obj.Status.Replicas != obj.Status.ReadyReplicas </span><span class="cov0" title="0">{
                if len(obj.Status.Conditions) &gt; 0 </span><span class="cov0" title="0">{
                        return ErrReplicasNotReady(obj.Status.Conditions[0].Reason)
                }</span>
                <span class="cov0" title="0">return ErrReplicasNotReady("Condition Unknown")</span>
        }

        <span class="cov8" title="1">if len(obj.Status.Conditions) &gt; 0 &amp;&amp; (obj.Status.Conditions[0].Status == corev1.ConditionFalse || obj.Status.Conditions[0].Status == corev1.ConditionUnknown) </span><span class="cov0" title="0">{
                return ErrConditionFalse(obj.Status.Conditions[0].Reason)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetEndpoint returns those endpoints in the given service which match the selector.
func GetEndpoint(ctx context.Context, m *meshplayv1alpha1.Broker, client *kubernetes.Clientset, url string) error <span class="cov8" title="1">{

        var serviceObj *corev1.Service
        var err error
        var newUrl *neturl.URL
        var host string

        serviceObj, err = client.CoreV1().Services(m.ObjectMeta.Namespace).Get(ctx, m.ObjectMeta.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return ErrGettingResource(err)
        }</span>

        <span class="cov8" title="1">var nodePort, clusterPort int32
        endpoint := utils.Endpoint{}

        for _, port := range serviceObj.Spec.Ports </span><span class="cov8" title="1">{
                nodePort = port.NodePort
                clusterPort = port.Port
                if port.Name == "client" </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        // get clusterip endpoint
        <span class="cov8" title="1">endpoint.Internal = &amp;utils.HostPort{
                Address: serviceObj.Spec.ClusterIP,
                Port:    clusterPort,
        }
        // Initialize nodePort type endpoint
        endpoint.External = &amp;utils.HostPort{
                Address: "localhost",
                Port:    nodePort,
        }
        if serviceObj.Status.Size() &gt; 0 &amp;&amp; serviceObj.Status.LoadBalancer.Size() &gt; 0 &amp;&amp; len(serviceObj.Status.LoadBalancer.Ingress) &gt; 0 &amp;&amp; serviceObj.Status.LoadBalancer.Ingress[0].Size() &gt; 0 </span><span class="cov0" title="0">{
                if serviceObj.Status.LoadBalancer.Ingress[0].IP == "" </span><span class="cov0" title="0">{
                        endpoint.External.Address = serviceObj.Status.LoadBalancer.Ingress[0].Hostname
                        endpoint.External.Port = clusterPort
                }</span> else<span class="cov0" title="0"> if serviceObj.Status.LoadBalancer.Ingress[0].IP == serviceObj.Spec.ClusterIP || serviceObj.Status.LoadBalancer.Ingress[0].IP == "&lt;pending&gt;" </span><span class="cov0" title="0">{
                        if url != "" </span><span class="cov0" title="0">{
                                newUrl, err = neturl.Parse(url)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">host, _, err = net.SplitHostPort(newUrl.Host)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">endpoint.External.Address = host
                                endpoint.External.Port = nodePort</span>
                        } else<span class="cov0" title="0"> {
                                endpoint.External.Address = serviceObj.Spec.ClusterIP
                                endpoint.External.Port = clusterPort
                        }</span>
                } else<span class="cov0" title="0"> {
                        endpoint.External.Address = serviceObj.Status.LoadBalancer.Ingress[0].IP
                        endpoint.External.Port = clusterPort
                }</span>
        }
        // Service Type ClusterIP
        <span class="cov8" title="1">if endpoint.External.Port == 0 </span><span class="cov0" title="0">{
                endpoint.Internal = &amp;utils.HostPort{}
        }</span>
        // If external endpoint not reachable
        <span class="cov8" title="1">if !utils.TcpCheck(endpoint.External, &amp;utils.MockOptions{}) &amp;&amp; endpoint.External.Address != "localhost" </span><span class="cov0" title="0">{
                newUrl, err = neturl.Parse(url)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">host, _, err = net.SplitHostPort(newUrl.Host)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // Set to APIServer host (For minikube specific clusters)
                <span class="cov0" title="0">endpoint.External.Address = host
                // If still unable to reach, change to resolve to clusterPort
                if !utils.TcpCheck(endpoint.External, &amp;utils.MockOptions{}) &amp;&amp; endpoint.External.Address != "localhost" </span><span class="cov0" title="0">{
                        endpoint.External.Port = nodePort
                        if !utils.TcpCheck(endpoint.External, &amp;utils.MockOptions{}) </span><span class="cov0" title="0">{
                                return ErrGettingEndpoint(err)
                        }</span>
                }
        }

        <span class="cov8" title="1">m.Status.Endpoint.External = fmt.Sprintf("%s:%d", endpoint.External.Address, endpoint.External.Port)
        m.Status.Endpoint.Internal = fmt.Sprintf("%s:%d", endpoint.Internal.Address, endpoint.Internal.Port)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2023 Khulnasoft, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package broker

import (
        "errors"
)

const (
        ErrGettingResourceCode  = "1013"
        ErrReplicasNotReadyCode = "1014"
        ErrConditionFalseCode   = "1015"
        ErrGettingEndpointCode  = "1016"
)

func ErrGettingResource(err error) error <span class="cov8" title="1">{
        return errors.New(ErrGettingResourceCode + ":" + "Unable to get resource")
}</span>

func ErrGettingEndpoint(err error) error <span class="cov8" title="1">{
        return errors.New(ErrGettingEndpointCode + ":" + "Unable to get endpoint")
}</span>

func ErrReplicasNotReady(reason string) error <span class="cov8" title="1">{
        return errors.New(ErrReplicasNotReadyCode + ":" + "The replicas are not ready")
}</span>

func ErrConditionFalse(reason string) error <span class="cov8" title="1">{
        return errors.New(ErrConditionFalseCode + ":" + "The condition is false")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2023 Khulnasoft, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package meshsync

import (
        meshplayv1alpha1 "github.com/khulnasoft/meshplay-operator/api/v1alpha1"
        v1 "k8s.io/api/apps/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
)

const (
        ServerObject = "server-object"
)

type Object interface {
        runtime.Object
        metav1.Object
}

func GetObjects(m *meshplayv1alpha1.MeshSync) map[string]Object <span class="cov8" title="1">{
        return map[string]Object{
                ServerObject: getServerObject(m.ObjectMeta.Namespace, m.ObjectMeta.Name, m.Spec.Size, m.Status.PublishingTo),
        }
}</span>

func getServerObject(namespace, name string, replicas int32, url string) Object <span class="cov8" title="1">{
        var obj = &amp;v1.Deployment{}
        Deployment.DeepCopyInto(obj)
        obj.ObjectMeta.Namespace = namespace
        obj.ObjectMeta.Name = name
        obj.Spec.Replicas = &amp;replicas
        obj.Spec.Template.Spec.Containers[0].Env[0].Value = url // Set broker endpoint
        return obj
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
